using System.Security;
using AppBlueprint.Application.Interfaces;
using AppBlueprint.Infrastructure.DatabaseContexts;
using AppBlueprint.Infrastructure.DatabaseContexts.Baseline.Entities.User;
using AppBlueprint.Infrastructure.DatabaseContexts.Baseline.Entities.User.Profile;
using AppBlueprint.Infrastructure.DatabaseContexts.Interceptors;
using AppBlueprint.Infrastructure.Services;
using AppBlueprint.SharedKernel;
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging.Abstractions;
using Moq;
using Npgsql;
using Testcontainers.PostgreSql;

namespace AppBlueprint.Tests.Integration;

internal class TenantSecurityExploitTests
{
    private readonly PostgreSqlContainer _container = new PostgreSqlBuilder()
        .WithImage("postgres:17-alpine")
        .Build();

    private string ConnectionString => _container.GetConnectionString();
    private string? _rlsUserConnectionString;

    [Before(Test)]
    public async Task InitializeAsync()
    {
        await _container.StartAsync();
        await ApplyMigrationsAndSeedAsync();

        // Create a non-superuser for testing RLS
        var builder = new NpgsqlConnectionStringBuilder(ConnectionString);
        using var conn = new NpgsqlConnection(ConnectionString);
        await conn.OpenAsync();
        using var cmd = conn.CreateCommand();
        cmd.CommandText = @"
            DO $$
            BEGIN
              IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'rls_test_user') THEN
                CREATE ROLE rls_test_user WITH LOGIN PASSWORD 'rls_test_pass';
              END IF;
            END
            $$;
            GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO rls_test_user;
            GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO rls_test_user;
        ";
        await cmd.ExecuteNonQueryAsync();

        builder.Username = "rls_test_user";
        builder.Password = "rls_test_pass";
        _rlsUserConnectionString = builder.ConnectionString;
    }

    [After(Test)]
    public async Task CleanupAsync()
    {
        await _container.StopAsync();
    }

    private async Task ApplyMigrationsAndSeedAsync()
    {
        // Use a setup context to migrate and seed
        await using var context = CreateContext("tenant-setup");
        await context.Database.MigrateAsync();

        // Add RLS Policies manually if they are not in migrations yet
        // Ensuring RLS is enabled for users table to test Layer 2
        await context.Database.ExecuteSqlRawAsync(@"
            ALTER TABLE ""Users"" ENABLE ROW LEVEL SECURITY;
            ALTER TABLE ""Users"" FORCE ROW LEVEL SECURITY;
            
            DROP POLICY IF EXISTS ""TenantIsolation"" ON ""Users"";
            
            CREATE POLICY ""TenantIsolation"" ON ""Users""
            USING (""TenantId"" = current_setting('app.current_tenant_id', true))
            WITH CHECK (""TenantId"" = current_setting('app.current_tenant_id', true));
        ");

        // Seed Tenants
        context.Tenants.Add(new AppBlueprint.Infrastructure.DatabaseContexts.Baseline.Entities.Tenant.TenantEntity
        {
            Id = "tenant-a",
            Name = "Tenant A"
        });
        context.Tenants.Add(new AppBlueprint.Infrastructure.DatabaseContexts.Baseline.Entities.Tenant.TenantEntity
        {
            Id = "tenant-b",
            Name = "Tenant B"
        });

        // Seed Tenant A
        context.Users.Add(new UserEntity
        {
            Id = Guid.NewGuid().ToString(),
            TenantId = "tenant-a",
            Email = "user@tenant-a.com",
            FirstName = "Alice",
            LastName = "A",
            UserName = "alice_a",
            Profile = new ProfileEntity()
        });

        // Seed Tenant B
        context.Users.Add(new UserEntity
        {
            Id = Guid.NewGuid().ToString(),
            TenantId = "tenant-b",
            Email = "user@tenant-b.com",
            FirstName = "Bob",
            LastName = "B",
            UserName = "bob_b",
            Profile = new ProfileEntity()
        });

        await context.SaveChangesAsync();
    }

    private ApplicationDbContext CreateContext(string tenantId)
    {
        var cs = _rlsUserConnectionString ?? ConnectionString;
        var optionsBuilder = new DbContextOptionsBuilder<ApplicationDbContext>();
        optionsBuilder.UseNpgsql(cs);
        optionsBuilder.EnableSensitiveDataLogging();
        optionsBuilder.ConfigureWarnings(x => x.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.PendingModelChangesWarning));

        // Mock Tenant Context
        var mockTenantContext = new Mock<ITenantContextAccessor>();
        mockTenantContext.Setup(x => x.TenantId).Returns(tenantId);

        // Add security interceptors to the test context
        optionsBuilder.AddInterceptors(new TenantSecurityInterceptor(mockTenantContext.Object));
        optionsBuilder.AddInterceptors(new TenantRlsInterceptor(mockTenantContext.Object));

        // create logger
        var logger = NullLogger<ApplicationDbContext>.Instance;
        var config = new ConfigurationBuilder().Build();

        // 1. Interceptor for RLS (Layer 2)
        var connectionInterceptor = new TenantConnectionInterceptor(mockTenantContext.Object, NullLogger<TenantConnectionInterceptor>.Instance);

        // 2. Interceptor for Write Protection (Layer 1b)
        var securityInterceptor = new TenantSecurityInterceptor(mockTenantContext.Object);

        optionsBuilder.AddInterceptors(connectionInterceptor, securityInterceptor);

        return new ApplicationDbContext(optionsBuilder.Options, config, logger, mockTenantContext.Object);
    }

    [Test]
    public async Task Exploit_Read_GlobalQueryFilter_Should_Filter_CrossTenantData()
    {
        // Arrange: Logged in as Tenant A
        await using var context = CreateContext("tenant-a");

        // Act: Try to read all users (should theoretically see Tenant B if filters fail)
        var users = await context.Users.ToListAsync();

        // Assert: key defense #1 (Application Layer) should filter it
        users.Should().Contain(u => u.TenantId == "tenant-a");
        users.Should().NotContain(u => u.TenantId == "tenant-b");
    }

    [Test]
    public async Task Exploit_Read_IgnoreQueryFilters_Should_Still_Be_Blocked_By_RLS()
    {
        // Arrange: Logged in as Tenant A
        await using var context = CreateContext("tenant-a");

        // Act: Try to bypass Layer 1 using IgnoreQueryFilters
        // This simulates a developer mistake or an exploit where the filter is disabled
        // Layer 2 (Postgres RLS) must catch this.
        var users = await context.Users.IgnoreQueryFilters().ToListAsync();

        // Assert: key defense #2 (Database Layer) should return NOTHING for other tenants
        // RLS policy: USING (TenantId = current_setting('app.current_tenant_id'))
        // So we should see "tenant-a" (allowed) but ABSOLUTELY NOT "tenant-b"
        users.Should().NotContain(u => u.TenantId == "tenant-b");
        users.Should().Contain(u => u.TenantId == "tenant-a");
    }

    [Test]
    public async Task Exploit_Write_CrossTenantReference_Should_Throw_SecurityException()
    {
        // Arrange: Logged in as Tenant A
        await using var context = CreateContext("tenant-a");

        // Act: Try to maliciously update Tenant B's user
        // We create a fake entity stub that mimics Tenant B's existing user
        var maliciousUpdate = new UserEntity
        {
            Id = Guid.NewGuid().ToString(), // New ID or existing one
            TenantId = "tenant-b", // THE EXPLOIT: Referring to another tenant
            Email = "hacked@tenant-b.com",
            FirstName = "Hacked",
            LastName = "Hacked",
            UserName = "hacker",
            Profile = new ProfileEntity()
        };

        // Attach as Modified to simulate an update attempt
        context.Entry(maliciousUpdate).State = EntityState.Modified;

        // Assert: TenantSecurityInterceptor (Layer 1b) should catch this immediately
        Func<Task> action = async () => await context.SaveChangesAsync();

        await action.Should().ThrowAsync<SecurityException>()
            .WithMessage("*Cross-tenant modification detected*");
    }

    [Test]
    public async Task Exploit_Delete_CrossTenantReference_Should_Throw_SecurityException()
    {
        // Arrange: Logged in as Tenant A
        await using var context = CreateContext("tenant-a");

        var maliciousDelete = new UserEntity
        {
            Id = Guid.NewGuid().ToString(),
            TenantId = "tenant-b", // Target Tenant B
            FirstName = "To",
            LastName = "Delete",
            Email = "delete@me.com",
            UserName = "delete_me",
            Profile = new ProfileEntity()
        };

        context.Entry(maliciousDelete).State = EntityState.Deleted;

        Func<Task> action = async () => await context.SaveChangesAsync();

        await action.Should().ThrowAsync<SecurityException>()
            .WithMessage("*Cross-tenant modification detected*");
    }
}
